## 问题

sizeof 与 strlen 的区别与使用详解。

## 区别

1. `strlen` 是一个函数，只能以 `char*` (字符串)作为参数，用来计算指定字符串` str` 的长度，但不包括结束字符` '\0'`。所以其参数必须是以` '\0'`作为结束符才可以正确统计其字符长度，否则是个随机数，具体看下面的代码。
2. `sizeof` 是一个单目运算符，它的参数可以是数组、指针、字符串、对象等等，计算的是参数所对应内存空间的实际字节数。
3. 在统计字符串 `str` 的长度时，包含结束字符 `'\0'`

**具体看下面的代码进一步理解：**

```c++
#include <bits/stdc++.h> 
using namespace std;
int main() {
    char* s1 = "0123456789";
    cout<<sizeof(s1)<<endl;  // 输出 8，因为这时的参数 s 是一个指向字符串常量的字符指针，因此计算的是指针的大小，注意这里不同编译器得到的值可能不同，也有可能是4
    cout<<sizeof(*s1)<<endl;  // 输出 1，*s 是第一个字符
    cout<<strlen(s1)<<endl;  // 输出 10，有10个字符，strlen是个函数，内部实现是用一个循环计算到\0之前为止
    //strlen(*s1);  // 报错，因为strlen函数的参数类型只能是 char* 即字符串
    
    char s2[] = "0123456789";  // 数组
    cout<<sizeof(s2)<<endl;  // 结果为11，数组名虽然本质上是一个指针，但是作为sizeof的参数时，计算的是整个数组的大小，这点要特别注意。且在求动态数组的大小时，sizeof统计到第一个结束字符'\0'处结束
    cout<<strlen(s2)<<endl;  // 结果为10
    cout<<sizeof(*s2)<<endl;  // 结果为1，*s是第一个字符
    
    char s3[100] = "0123456789";
    cout<<sizeof(s3)<<endl;  // 结果为100，因为内存给数组 s3分配了字节数为100的空间大小
    cout<<strlen(s3)<<endl;  // 结果为10
    
    int s4[100] = {0,1,2,3,4,5,6,7,8,9};
    cout<<sizeof(s4)<<endl;  // 结果为400，因为int数组中每个元素都是int型，int型占用4字节
    //strlen(s4);  // 报错，strlen不能以int* 作为函数参数
    
    char p[] = {'a', 'b','c','d','e', 'f', 'g','h'};
    char q[] = {'a', 'b','c','d','\0', 'e', 'f', 'g'};
    cout<<sizeof(p)<<endl;  // 结果为8
    cout<<strlen(p)<<endl;  // 结果是一个随机数，因为字符串数组中没有结束字符 '\0', 因此该函数会一直统计下去，直到碰到内存中的结束字符
    cout<<sizeof(q)<<endl;  // 结果还是8
    cout<<strlen(q)<<endl;  // 结果为4, 结束字符 '\0'前有4个字符
    return 0;
}
```

另外`sizeof`在**统计结构体的大小时还有一个内存对齐的问题**，具体如下：

```c++
struct Stu {
    int i;
    int j;
    char k;
}；

Stu stu;
cout<<sizeof(stu)<<endl;  // 输出 12
```

这个例子是结构体的内存对齐所导致的，计算结构变量的大小就必须讨论数据对齐问题。为了CPU存取的速度最快（这同CPU取数操作有关），C语言在处理数据时经常把结构变量中的成员的大小按照4或8的倍数计算，这就叫**数据对齐**（data alignment）。这样做可能会浪费一些内存，但理论上速度快了。当然这样的设置会在读写一些别的应用程序生成的数据文件或交换数据时带来不便。



------

c/c++中获取字符串长度。有以下函数：str.size()、sizeof() 、strlen()、str.length();

一、数组或字符串的长度:sizeof()、strlen()

1、sizeof():返回所占总空间的字节数

2、strlen():返回字符数组或字符串所占的字节数

sizeof(...)是运算符，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。

strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符'\0'。返回的长度大小不包括'\0'。

strlen(char*)函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个'\0',如果你只定义没有给它赋初值，这个结果是不定的，它会从aa首地址一直找下去，直到遇到'\0'停止。

c/c++ strlen(str)和str.length()和str.size()都可以求字符串长度。

其中str.length()和str.size()是用于求string类对象的成员函数

strlen(str)是用于求字符数组的长度，其参数是char*。

举例：

```c++
1）char* ss = "0123456789";
```

sizeof(ss)为4，ss是指向字符串常量的字符指针，sizeof 获得的是指针所占的空间,则为4

sizeof(*ss)为1，*ss是第一个char字符，则为1

```c++
2）char ss[] = "0123456789";
```

sizeof(ss)为11,ss是数组，计算到'\0'位置，因此是(10+1)

sizeof(*ss)为1,*ss是第一个字符

3）char ss[100] = "0123456789";

sizeof(ss)为100，ss表示在内存中预分配的大小，100*1

strlen(ss)为10，它的内部实现用一个循环计算字符串的长度,直到'\0'为止。

4）int ss[100] = "0123456789";

sizeof(ss)为400，ss表示在内存中预分配的大小，100*4

strlen(ss)错误，strlen参数只能是char*，且必须是以'\0'结尾

5）char[] a={'a','b','c'};

sizeof(a)的值应该为3。

char[] b={"abc"};

sizeof(b)的值应该是4。

若string str={'a','b','c','\0','X'};

那么sizeof(str)为5，strlen(str)为3。

sizeof()、strlen()两者区别：

1）sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。 

该类型保证能容纳实现所建立的最大对象的字节大小。 

2）sizeof是运算符，strlen是函数。 

3）sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以''\0''结尾的。 

sizeof还可以用函数做参数，比如： 

```C++
short f(); 

printf("%d\n", sizeof(f())); 
```

输出的结果是sizeof(short)，即2。 

4）数组做sizeof的参数不退化，传递给strlen就退化为指针了。 

5）大部分编译程序 在编译的时候就把sizeof计算过了，是类型或是变量的长度。这就是sizeof(x)可以用来定义数组维数的原因 

```c++
char str[20]="0123456789"; 

int a=strlen(str); //a=10; 

int b=sizeof(str); //而b=20; 
```

6）strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度，不是类型占内存的大小。 

7）sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。 

8）当使用了一个结构类型或变量时， sizeof 返回实际的大小， 当使用一静态地空间数组， sizeof 返回全部数组的尺寸。 sizeof 操作符不能返回被动态分配的数组或外部的数组的尺寸 

二、string中length()和size()

c++中的size()和length()没有区别

如：

```c++
string str="0123456789";

cout <<"str.length()="<<str.length()<<endl;//结果为10

cout <<"str.size()="<<str.size()<<endl;//结果为10
```

为了兼容，这两个函数一样。 length()是因为沿用C语言的习惯而保留下来的，string类最初只有length()，引入STL之后，为了兼容又加入了size()，它是作为STL容器的属性存在的，便于符合STL的接口规则，以便用于STL的算法。 string类的size()/length()方法返回的是字节数，不管是否有汉字。
