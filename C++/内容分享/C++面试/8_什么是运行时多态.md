## 问题

什么是运行时多态？



## 运行时多态

首先要理解什么是多态？

多态的实现主要分为静态多态和动态多态，静态多态主要是重载（overload），在编译时就已经确定；而动态多态是通过虚函数机制来实现，在运行时动态绑定。

**动态多态是指基类的指针指向其派生类的对象，通过基类的指针来调用派生类的成员函数。**

```c++
int main() {
    Base a;
	Derived b;			//派生类的对象
    Base *p1 = &a;
	Base *p2 = &b;		//基类的指针，指向派生类的对象
    p1->f1();
	p2->f1();  //基类的指针调用派生类重写的虚函数 Derived::f1(), 打印结果为 Derived::f1
	return 0;
}
```

如果基类通过引用或者指针调用的是非虚函数，无论实际的对象是什么类型，都执行基类所定义的函数。即：

```C++
int main() {
    Base a;
	Derived b;
    Base *p = &a;		//基类的指针，指向基类的对象
    Base *p0 = &b;		//基类的指针，指向派生类的对象
    //f()是非虚函数，所以无论指向是基类的对象a还是派生类的对象b，执行的都是基类的函数f()
    p->f();
    p0->f();
	return 0;
}
```



**C++类的多态性是通过虚函数来实现的。如果基类通过引用或指针调用的是虚函数时，我们并不知道执行该函数的对象是什么类型的，只有在运行时才能确定调用的是基类的虚函数还是派生类中的虚函数，这就是运行时多态。**

```C++
int main() {
    Base a;
	Derived b;
    Base *p1 = &a;		//基类的指针，指向基类的对象
    Base *p2 = &b;		//基类的指针，指向派生类的对象
    //f1()是虚函数,只有运行时才知道真正调用的是基类的f1(),还是派生类的f1()
    p1->f1();	//p1指向的是基类的对象，所以此时调用的是基类的f1()
    p2->f1();	//p2指向的是派生类的对象，所以调用的是派生类重写后的f1()
	return 0;
}
```

总结一下：

**多态性其实就是想让基类的指针具有多种形态，能够在尽量少写代码的情况下让基类可以实现更多的功能**。比如说，派生类重写了基类的虚函数f1()之后，基类的指针就不仅可以调用自身的虚函数f1()，还可以调用其派生类的虚函数f1()。



## 虚函数与静态函数的区别

**静态函数在编译时已经确定，而虚函数是在运行时动态绑定的**。

虚函数因为用了虚函数表的机制，所以在调用的时候会**增加一次内存开销**。

