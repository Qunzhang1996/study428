## 问题

什么是左值引用和右值引用？

## 解答

在 C++ 中所有的值必属于左值、右值两者之一。

**左值**：可以取地址的，有名字的，非临时的
**右值**：不能取地址的，没有名字的，临时的

可见**临时值，函数返回的值**等都是右值；而**非匿名对象(包括变量)，函数返回的引用，const对象**等都是左值。



### 左值引用

所谓的左值引用就是对左值的引用。先看一下传统的左值引用：**结论：**

>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用**常引用**。但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。

### 右值引用

右值引用是 C++11 新增的特性，右值引用用来绑定到右值，绑定到右值以后，本来会被销毁的右值的生存期会延长到与绑定到它的右值引用的生存期。（有点绕，多读两遍）

定义右值引用的格式如下：

```c++
类型 && 引用名 = 右值表达式;
int &&c = 10;
```

在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。



右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。

带右值引用参数的拷贝构造和赋值重载函数，又叫**移动构造函数**和**移动赋值函数**，这里的移动指的是把临时量的资源移动给了当前对象，临时对象就不持有资源，为nullptr了，实际上没有进行任何的数据移动，没发生任何的内存开辟和数据拷贝。

**注意：**

右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要使用 `std::move()` 函数将左值强制转换为右值，如：

```c++
int val = 10;
int &&rrval = std::move(val);
```

但是这里需要注意：在调用完`std::move()`之后，不能再使用val，只能使用 rrval，这一点用于基本类型可能没什么直接影响，当应用到类函数的时候，用好`std::move()` 可以减少构造函数数的次数。

